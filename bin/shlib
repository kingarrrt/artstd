# shlib: not really sh, but common between bash and zsh

# NOTE: function names cannot contain "-", this blows zsh in some compatibility modes

# options for non-interactive
[[ $- =~ i ]] || set -euo pipefail

arg0_basename() {
  basename "$0" | sed "s/^\.//"
}

color() {
  printf "\e[%dm%s\e[m" "$@"
}

_log() {
  local args=(-e) message color=$1
  shift
  if [[ $1 == -n ]]; then
    args+=("$1")
    shift
  fi
  message="$*"
  [[ -n ${CLICOLOR_FORCE:-} || -t 2 ]] && message="$(color $color "$message")"
  echo "${args[@]}" "$message" >&2
}

debug() {
  _log 2 "$@"
}

info() {
  _log 37 "$@"
}

success() {
  _log 32 "$@"
}

warn() {
  _log 33 "$@"
}

error() {
  _log 31 "$@"
}

fail() {
  local code=${2:-1}
  error "$1 (exit=$code)"
  return $code
}

die() {
  error "$1"
  return ${2:-1}
}

TMP_PATHS=()
trap '[[ -z ${TMP_PATHS:-} ]] || rm -rf ${TMP_PATHS[*]}' EXIT

tmpfile() {
  local tmp
  tmp=$(mktemp -t "${1:-$(arg0_basename)}.XXXXXX")
  TMP_PATHS+=($tmp)
  echo $tmp
}

tmpdir() {
  local tmp
  tmp=$(mktemp -dt "${1:-$(arg0_basename)}.XXXXXX")
  TMP_PATHS+=($tmp)
  echo $tmp
}

oneatatime() {
  local lock
  lock=$XDG_RUNTIME_DIR/$(arg0_basename).lock
  if [[ -f $lock ]]; then
    exit 0
  fi
  touch "$lock"
  # shellcheck disable=2064
  trap "rm $lock" EXIT
}

logtrace() {
  exec &>>"/tmp/${1:-$(arg0_basename)}.log"
  echo
  echo "*** $(date)"
  set -x
}

# https://stackoverflow.com/a/17841619
join() {
  local d=${1-} f=${2-}
  if shift 2; then
    printf %s "$f" "${@/#/$d}"
  fi
}

map() {
  local eval=$1 el out=()
  shift
  for el in "$@"; do
    set -- $el
    # shellcheck disable=2207
    out+=($(eval echo $eval))
  done
  echo "${out[@]}"
}

mapfunc() {
  local func=$1
  shift
  map "\$($func \$1)" "$@"
}

# first argument is printf template and must contain "%s"
mapstr() {
  local tpl="$1" el out=()
  shift
  for el in "$@"; do
    # shellcheck disable=2059,2207
    out+=($(printf "$tpl" $el))
  done
  echo "${out[@]}"
}

has() {
  command -v $1 >/dev/null
}

relpath() {
  local abspath=${1:-}
  if [[ -z $abspath ]]; then
    abspath=$(</dev/stdin)
  fi
  local relpath="${abspath#"$HOME"}"
  if [[ $relpath != $abspath ]]; then
    abspath="~$relpath"
  fi
  echo $abspath
}

flatpath() {
  local relpath
  relpath=$(relpath $1)
  echo ${relpath//\//%}
}

trace_ignore() {
  grep -Ev '^(\+(trace| (export [A-Z_]*PATH|[A-Z_]*PATH=))|\+\+ set -e)' 1>&2
}

rs() {
  rsync --info=progress2 "$@"
}

rsa() {
  rs --archive --hard-links --numeric-ids "$@"
}

rsad() {
  rsa --delete "$@"
}

# vim:ft=bash
